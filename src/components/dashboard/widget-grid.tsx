"use client";

import { useState, useCallback, useRef } from "react";
import { MetricCard } from "./metric-card";
import {
  Zap,
  Code2,
  Clock,
  TrendingUp,
  DollarSign,
  ArrowUpRight,
  ArrowDownRight,
  GitCommit,
  GitPullRequest,
  CheckCircle,
  GripVertical,
} from "lucide-react";
import type { LucideIcon } from "lucide-react";

export interface Widget {
  id: string;
  metricKey: string;
  displayName: string;
  description?: string | null;
  isEnabled: boolean;
  showInTopRow?: boolean;
  showInChart?: boolean;
  displayOrder: number;
  icon: string | null;
  color: string | null;
  format: string | null;
  category?: string | null;
}

interface WidgetGridProps {
  widgets: Widget[];
  metricValues: Record<string, number>;
  metricChanges: Record<string, number | null>;
  onReorder: (widgetId: string, newOrder: number) => void;
  isEditing?: boolean;
}

const iconMap: Record<string, LucideIcon> = {
  Zap,
  Code2,
  Clock,
  TrendingUp,
  DollarSign,
  ArrowUpRight,
  ArrowDownRight,
  GitCommit,
  GitPullRequest,
  CheckCircle,
};

const tooltips: Record<string, string> = {
  sessions: "Count of AI coding sessions started in the last 30 days.",
  linesOfCode: "Total lines added + modified with AI assistance.",
  hoursSaved: "Estimated time saved using AI vs manual coding.",
  roi: "Return on Investment: ((Value - Cost) / Cost) x 100",
  totalCost: "Total API cost in USD for all sessions.",
  inputTokens: "Total input tokens sent to the AI model.",
  outputTokens: "Total output tokens generated by the AI model.",
  activeTime: "Total active session time in minutes.",
  commits: "Git commits made during AI sessions.",
  pullRequests: "Pull requests created during AI sessions.",
};

export function WidgetGrid({
  widgets,
  metricValues,
  metricChanges,
  onReorder,
  isEditing = false,
}: WidgetGridProps) {
  const [draggedWidget, setDraggedWidget] = useState<string | null>(null);
  const [dragOverWidget, setDragOverWidget] = useState<string | null>(null);
  const dragCounter = useRef(0);

  // Filter and sort widgets - show all enabled ones
  const enabledWidgets = widgets
    .filter((w) => w.isEnabled)
    .sort((a, b) => a.displayOrder - b.displayOrder);

  const handleDragStart = useCallback((e: React.DragEvent, widgetId: string) => {
    setDraggedWidget(widgetId);
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", widgetId);

    // Add a slight delay to allow the drag image to be captured
    setTimeout(() => {
      const el = e.target as HTMLElement;
      el.style.opacity = "0.5";
    }, 0);
  }, []);

  const handleDragEnd = useCallback((e: React.DragEvent) => {
    const el = e.target as HTMLElement;
    el.style.opacity = "1";
    setDraggedWidget(null);
    setDragOverWidget(null);
    dragCounter.current = 0;
  }, []);

  const handleDragEnter = useCallback((e: React.DragEvent, widgetId: string) => {
    e.preventDefault();
    dragCounter.current++;
    if (widgetId !== draggedWidget) {
      setDragOverWidget(widgetId);
    }
  }, [draggedWidget]);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    dragCounter.current--;
    if (dragCounter.current === 0) {
      setDragOverWidget(null);
    }
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "move";
  }, []);

  const handleDrop = useCallback((e: React.DragEvent, targetWidgetId: string) => {
    e.preventDefault();
    const sourceWidgetId = e.dataTransfer.getData("text/plain");

    if (sourceWidgetId && sourceWidgetId !== targetWidgetId) {
      const targetWidget = widgets.find((w) => w.id === targetWidgetId);
      if (targetWidget) {
        onReorder(sourceWidgetId, targetWidget.displayOrder);
      }
    }

    setDraggedWidget(null);
    setDragOverWidget(null);
    dragCounter.current = 0;
  }, [widgets, onReorder]);

  if (enabledWidgets.length === 0) {
    return (
      <div className="rounded-lg border border-dashed border-border bg-background-secondary/50 p-8 text-center">
        <p className="text-foreground-muted">
          No widgets enabled. Click "Add Data" to add metrics to your dashboard.
        </p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5">
      {enabledWidgets.map((widget) => {
        const IconComponent = widget.icon ? iconMap[widget.icon] : Zap;
        const value = metricValues[widget.metricKey] ?? 0;
        const change = metricChanges[widget.metricKey];
        const isDragging = draggedWidget === widget.id;
        const isDragOver = dragOverWidget === widget.id;

        return (
          <div
            key={widget.id}
            draggable={isEditing}
            onDragStart={(e) => handleDragStart(e, widget.id)}
            onDragEnd={handleDragEnd}
            onDragEnter={(e) => handleDragEnter(e, widget.id)}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={(e) => handleDrop(e, widget.id)}
            className={`relative transition-all ${
              isEditing ? "cursor-grab active:cursor-grabbing" : ""
            } ${isDragging ? "opacity-50" : ""} ${
              isDragOver ? "ring-2 ring-accent-cyan ring-offset-2 ring-offset-background" : ""
            }`}
          >
            {isEditing && (
              <div className="absolute -left-2 top-1/2 z-10 -translate-y-1/2 rounded bg-background-secondary p-1 opacity-0 transition-opacity group-hover:opacity-100 hover:opacity-100">
                <GripVertical className="h-4 w-4 text-foreground-muted" />
              </div>
            )}
            <MetricCard
              title={widget.displayName}
              value={value}
              format={widget.format as "number" | "currency" | "percentage" | "duration" | "tokens" || "number"}
              change={change ?? undefined}
              icon={IconComponent}
              color={widget.color as "cyan" | "purple" | "green" | "pink" | "yellow" | "red" || "cyan"}
              tooltip={tooltips[widget.metricKey] ?? widget.description ?? undefined}
            />
          </div>
        );
      })}
    </div>
  );
}
